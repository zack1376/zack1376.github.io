<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Array.sort与函数式编程</title>
    <link href="/2024/08/22/Array-sort%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/08/22/Array-sort%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Array-sort-与函数式编程"><a href="#Array-sort-与函数式编程" class="headerlink" title="Array.sort()与函数式编程"></a><code>Array.sort()</code>与函数式编程</h1><p>在做力扣<a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a>时，遇到了一个问题：在解题过程中需要对区间进行排序，排序的依据是区间的左区间值。但是<code>Array.sort()</code>的无参数使用却并不是按照这个依据进行排序的，现在应该怎么办？</p><h2 id="Array-sort-方法的原理"><a href="#Array-sort-方法的原理" class="headerlink" title="Array.sort()方法的原理"></a><code>Array.sort()</code>方法的原理</h2><ul><li>原始类型数组：使用了一种改进的双轴快速排序算法</li><li>对象数组：使用的是一种基于归并排序和插入排序的混合排序算法</li></ul><p>当然这不是问题的关键，关键是在排序的过程中如何实现比较？</p><ul><li>如果对象实现了<code>Comparable</code>接口，并重载了<code>compareTo</code>方法，那么sort可以根据该方法返回的<code>int</code>类型数字进行排序</li><li>如果不想修改类来实现<code>Comparable</code>接口，那么可以使用<code>Comparator</code>接口。同样的，<code>Comparator</code>接口有一个<code>compare</code>方法，可以根据输入的两个对象的大小来返回<code>int</code>类型数字。</li><li>如果这两个接口都没有实现，<code>Arrays.sort()</code> 方法时会抛出 <code>java.lang.ClassCastException</code> 异常。</li></ul><p>显然在排序区间的时候，我们定义了一个二维数组<code>int[][]</code>，本身就实现了<code>Comparable</code>接口，但排序逻辑和我们需要的并不一样，所以我们应该通过<code>Comparator</code>接口来自定义比较方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(T[] a, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; c)</span>;<br></code></pre></td></tr></table></figure><p><code>Array.sort()</code>有这样一个原型方法，要求我们传入一个<code>Comparator</code>接口来指定排序规则，就是来做这件事的。</p><p>那我们该如何传入这个<code>Comparator</code>呢？</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程是一种编程范式，它强调使用函数的方式来处理数据，通常具有以下特征：</p><ol><li><strong>不可变性</strong>：数据一旦创建就不可更改，而是返回新数据。</li><li><strong>纯函数</strong>：相同输入总是返回相同输出，没有副作用（不依赖或修改全局状态）。</li><li><strong>高阶函数</strong>：可以接收函数作为参数或返回函数。</li></ol><p>Java 从 <code>Java 8</code> 开始引入了函数式编程的支持，主要通过 <code>Lambda</code> 表达式和 <code>Stream API</code> 来实现。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>Lambda 表达式是一种简洁的函数定义方式，通常用于实现函数接口的单个方法。它的语法如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span> expression<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;String&gt; byLength = (s1, s2) -&gt; s1.length() - s2.length();<br></code></pre></td></tr></table></figure><h2 id="结合-Arrays-sort-与函数式编程"><a href="#结合-Arrays-sort-与函数式编程" class="headerlink" title="结合 Arrays.sort() 与函数式编程"></a>结合 <code>Arrays.sort()</code> 与函数式编程</h2><p><code>Arrays.sort()</code> 和函数式编程可以结合使用。可以使用 Lambda 表达式来定义排序规则，从而让代码更加简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(people, (p1, p2) -&gt; p1.age - p2.age);<br></code></pre></td></tr></table></figure><p>同理，我们对于我们的需求也可以如此定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(intervals, (a, b)-&gt;a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>不过最好还是这么来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><p>以为上面的代码可能会造成整数溢出。一个不太恰当的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] intervals = &#123;<br>            &#123;Integer.MAX_VALUE, <span class="hljs-number">10</span>&#125;, <span class="hljs-comment">//区间左边值大不太合理</span><br>            &#123;Integer.MIN_VALUE, <span class="hljs-number">20</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 使用简单的 a[0] - b[0] 进行排序</span><br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">// 输出排序后的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>            System.out.println(Arrays.toString(interval));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么可以这样写？"><a href="#为什么可以这样写？" class="headerlink" title="为什么可以这样写？"></a>为什么可以这样写？</h2><p>第一次看这个代码的时候，我还是不太明白，不是函数原型要求传入一个<code>Comparator</code>类型的函数吗？上面的写法好像并没有显示的声明类型啊</p><p>首先，最最传统的写法应该是匿名内部类，关于匿名内部类可以看这篇博客：<a href="https://blog.csdn.net/yang_guang3/article/details/133298411">Java中的匿名内部类(看这篇就够了)_java获取匿名内部类-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//匿名内部类实现</span><br>Comparator&lt;<span class="hljs-type">int</span>[]&gt; myComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;<br><span class="hljs-keyword">return</span> Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>&#125;<br>&#125;;<br>Arrays.sort(intervals, myComparator);<br></code></pre></td></tr></table></figure><p>使用lambda表达式可以简化这一写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用lambda表达式实现</span><br>Comparator&lt;<span class="hljs-type">int</span>[]&gt; myComparator = (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]);<br>Arrays.sort(intervals, myComparator);<br></code></pre></td></tr></table></figure><p>当然我们也没必要显式的声明<code>Comparator&lt;int[]&gt;</code>，在 Java 中，当你使用 lambda 表达式 <code>(a, b) -&gt; Integer.compare(a[0], b[0])</code> 时，编译器会自动将其转换成一个实现了 <code>Comparator&lt;int[]&gt;</code> 接口的对象。这个过程不需要显式地声明 <code>Comparator&lt;int[]&gt;</code>，因为 lambda 表达式的目标类型由上下文决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不用显式的声明`Comparator&lt;int[]&gt;`</span><br>Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Array.sort()</code>依据两个接口实现比较，若需要自定义比较方式，可以通过传入一个<code>compare</code>函数，使用lambda表达式可以很方便完成这一步。</p><ul><li><strong>推荐使用</strong>：<code>Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[0], b[0]));</code><ul><li>这种写法更安全，避免了整数溢出问题。</li><li>可读性更高，让人一眼就能看出这段代码是在比较两个整数。</li></ul></li><li><strong>不推荐使用</strong>：<code>Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</code><ul><li>虽然简洁，但在处理极端情况下可能会导致错误的比较结果。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍与升级版</title>
    <link href="/2024/08/19/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <url>/2024/08/19/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍与升级版打家劫舍"><a href="#打家劫舍与升级版打家劫舍" class="headerlink" title="打家劫舍与升级版打家劫舍"></a>打家劫舍与升级版打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a>是一道经典的一维动态规划题目，精简版的题目描述如下：</p><p>给定一个数组 <code>nums</code>，从这个数组中选出一系列数使得其和最大，并且这些数在原数组中不可以相邻。</p><p>假设用$max[1,\dots,n]$表示整个数组要求的结果，那么：<br>$$<br>\text{max}[i,\dots,n] &#x3D; \max\left{\text{nums}[i] + \text{max}[i+2,n], \text{max}[i+1,n]\right}<br>$$<br>由于我们一般习惯于从前向后计算，所以将上面公式修改为：<br>$$<br>\text{max}[1,\dots,i] &#x3D; \max\left{\text{nums}[i] + \text{max}[1,i-2], \text{max}[1,i-1]\right}, \forall i \geq 2<br>$$<br>为了避免重复计算，我们将计算好的$max[1,\dots,i]$$存储在数组<code>dp[i]</code>中，这样就可以写出动态规划的代码了。</p><p>如果我们还需要输出哪些数被选中了，那么只需要再使用一个数组<code>selected[]</code>存储<code>nums[i]</code>是否被选中，之后逆序遍历<code>selected[]</code>即可。</p><p>（为什么逆序遍历？这是因为数组的最开始那一位并不一定在整个结果中被选择，但有可能在之前的部分结果中被选择，所以正序遍历很难找到开始点。例如[9, 10, 10, 11]，结果为21，selected数组为[1,1,1,1]。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxNonAdjacentSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNonAdjacentSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + nums[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">boolean</span>[] selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];  <span class="hljs-comment">// 用于跟踪选择了哪些元素</span><br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">1</span>] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>            dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];<br>            selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>            selected[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>            selected[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; dp[i - <span class="hljs-number">2</span>] + nums[i]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>                selected[i] = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">2</span>] + nums[i];<br>                selected[i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印出选中的数</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (selected[i]) &#123;<br>                result.add(<span class="hljs-number">0</span>, nums[i]);<br>                i -= <span class="hljs-number">2</span>;  <span class="hljs-comment">// 如果选择了 nums[i]，那么就跳过 i 和 i-1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;  <span class="hljs-comment">// 如果没选择 nums[i]，就继续向前看</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;Maximum non-adjacent sum: &quot;</span> + maxNonAdjacentSum(nums)); <span class="hljs-comment">// 输出 15 (3 + 10 + 7)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们升级问题，要求被选择的数在原数组中至少相隔为k，那么如何解决问题呢？</p><p>首先在初始化<code>dp[]</code>的时候，就应该初始化前<code>k+1</code>位，所以此时应该用一个循环来初始化结果，之后不断计算<code>dp[i]</code>的时候，每次需要比较<code>nums[i]+dp[i-k-1],...,dp[i-1]</code>，所以这里需要一个循环来找到最大值。</p><p>同时更新<code>dp[i]</code>，<code>selected[i]</code>以及<code>currentMax</code>比较复杂，是本题的难点。</p><p>现在来修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxNonAdjacentSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNonAdjacentSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + nums[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">boolean</span>[] selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">includeCurrent</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (i - k &gt;= <span class="hljs-number">0</span>) &#123;<br>                includeCurrent += dp[i - k];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (includeCurrent &gt; dp[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = includeCurrent;<br>                selected[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (i - k &gt;= <span class="hljs-number">0</span>) &#123;<br>                    selected[i - k] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>                selected[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印出选中的数</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (selected[i]) &#123;<br>                result.add(<span class="hljs-number">0</span>, nums[i]);<br>                i -= k;  <span class="hljs-comment">// 如果选择了 nums[i]，那么就跳过 i 和前 k-1 个数</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;  <span class="hljs-comment">// 如果没选择 nums[i]，就继续向前看</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;Maximum non-adjacent sum with k=&quot;</span> + k + <span class="hljs-string">&quot;: &quot;</span> + maxNonAdjacentSum(nums, k));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>先更新还是先计数</title>
    <link href="/2024/08/15/%E5%85%88%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%85%88%E8%AE%A1%E6%95%B0/"/>
    <url>/2024/08/15/%E5%85%88%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%85%88%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣560：应该先计算前缀和还是先count"><a href="#力扣560：应该先计算前缀和还是先count" class="headerlink" title="力扣560：应该先计算前缀和还是先count"></a>力扣560：应该先计算前缀和还是先count</h1><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a>的标准做法是使用前缀和并通过哈希表优化，但是在主循环中，count和计算前缀和的顺序大部分解答都完全没有提及，看起来好像是不重要的，但是我在写这道题的时候却觉得没有那么“显然”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; preMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        preMap.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            pre = pre + nums[i];<br>            <span class="hljs-comment">// put or count first?</span><br>            <span class="hljs-keyword">if</span> (preMap.containsKey(pre - k)) &#123;<br>                count += preMap.get(pre - k);<br>            &#125;<br><br>            preMap(pre, preMap.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先说结论，必须是<strong>先put后count</strong>，不然在k&#x3D;0，且nums数组包含0的时候会出错。</p><h3 id="前缀和的思路"><a href="#前缀和的思路" class="headerlink" title="前缀和的思路"></a>前缀和的思路</h3><p>可以考虑$[i…j]$这个区间的和为k，</p><p>使用前缀和思想：$pre[j] - pre[i-1] &#x3D; k$</p><p>即$pre[j] &#x3D; k + pre[i-1]$</p><p>当我们遍历到$j$的时候，需要统计前面所有的$0,…,j-1$到$j$的和。</p><p>可以使用哈希表辅助查询，我们已经有了$pre[j]$</p><p>直接用该值去查询$key$对应的$value$即可。</p><h3 id="为什么要先put后count"><a href="#为什么要先put后count" class="headerlink" title="为什么要先put后count"></a>为什么要先put后count</h3><p>还是回到$pre[j] &#x3D; k+pre[i-1]$</p><p>其实我们就是需要找到$i-1$和$j$夹缝之间的一段序列，然后这段序列刚好为$k$，</p><p>那么如果先put，就意味着$i-1$可以等于$j$，继而夹缝为空，所以一段空数组等于$k$，显然不行。</p><p>所以就需要先put后count</p><h3 id="具体证明"><a href="#具体证明" class="headerlink" title="具体证明"></a>具体证明</h3><p>上面的说法看起来还不够有力，我们来具体证明一下吧。</p><p>只有当$k&#x3D;0$的时候有影响，因为只有当k&#x3D;0的时候，本次循环中put的pre[j]值才会立即被count表达式中的pre[j]-k用到，</p><p>所以只考虑$k&#x3D;0$的情况：</p><p>Map中存储的是各种前缀和的记录，如果是先put，我们考虑数组$[0,…,j-1]$都不为$0$，且$nums[j] &#x3D; 0$。</p><p>显然这时候从$pre[0]$到$pre[i]$都不为$0$，且$pre[i] &#x3D; pre[j]$。</p><p>那么在put的时候，因为$pre[i] &#x3D; pre[j]$，所以这一项的$value&#x3D;2$。</p><p>之后count的时候，显然count也为$2$，即和为$k$的子数组为$2$，显然错误，证明完毕。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
