<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>打家劫舍与升级版</title>
    <link href="/2024/08/19/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <url>/2024/08/19/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍与升级版打家劫舍"><a href="#打家劫舍与升级版打家劫舍" class="headerlink" title="打家劫舍与升级版打家劫舍"></a>打家劫舍与升级版打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a>是一道经典的一维动态规划题目，精简版的题目描述如下：</p><p>给定一个数组 <code>nums</code>，从这个数组中选出一系列数使得其和最大，并且这些数在原数组中不可以相邻。</p><p>假设用$max[1,\dots,n]$表示整个数组要求的结果，那么：<br>$$<br>\text{max}[i,\dots,n] &#x3D; \max\left{\text{nums}[i] + \text{max}[i+2,n], \text{max}[i+1,n]\right}<br>$$<br>由于我们一般习惯于从前向后计算，所以将上面公式修改为：<br>$$<br>\text{max}[1,\dots,i] &#x3D; \max\left{\text{nums}[i] + \text{max}[1,i-2], \text{max}[1,i-1]\right}, \forall i \geq 2<br>$$<br>为了避免重复计算，我们将计算好的$max[1,\dots,i]$$存储在数组<code>dp[i]</code>中，这样就可以写出动态规划的代码了。</p><p>如果我们还需要输出哪些数被选中了，那么只需要再使用一个数组<code>selected[]</code>存储<code>nums[i]</code>是否被选中，之后逆序遍历<code>selected[]</code>即可。</p><p>（为什么逆序遍历？这是因为数组的最开始那一位并不一定在整个结果中被选择，但有可能在之前的部分结果中被选择，所以正序遍历很难找到开始点。例如[9, 10, 10, 11]，结果为21，selected数组为[1,1,1,1]。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxNonAdjacentSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNonAdjacentSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + nums[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">boolean</span>[] selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];  <span class="hljs-comment">// 用于跟踪选择了哪些元素</span><br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">1</span>] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>            dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];<br>            selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>            selected[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>            selected[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; dp[i - <span class="hljs-number">2</span>] + nums[i]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>                selected[i] = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">2</span>] + nums[i];<br>                selected[i] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印出选中的数</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (selected[i]) &#123;<br>                result.add(<span class="hljs-number">0</span>, nums[i]);<br>                i -= <span class="hljs-number">2</span>;  <span class="hljs-comment">// 如果选择了 nums[i]，那么就跳过 i 和 i-1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;  <span class="hljs-comment">// 如果没选择 nums[i]，就继续向前看</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>&#125;;<br>        System.out.println(<span class="hljs-string">&quot;Maximum non-adjacent sum: &quot;</span> + maxNonAdjacentSum(nums)); <span class="hljs-comment">// 输出 15 (3 + 10 + 7)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们升级问题，要求被选择的数在原数组中至少相隔为k，那么如何解决问题呢？</p><p>首先在初始化<code>dp[]</code>的时候，就应该初始化前<code>k+1</code>位，所以此时应该用一个循环来初始化结果，之后不断计算<code>dp[i]</code>的时候，每次需要比较<code>nums[i]+dp[i-k-1],...,dp[i-1]</code>，所以这里需要一个循环来找到最大值。</p><p>同时更新<code>dp[i]</code>，<code>selected[i]</code>以及<code>currentMax</code>比较复杂，是本题的难点。</p><p>现在来修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxNonAdjacentSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNonAdjacentSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + nums[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">boolean</span>[] selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        selected[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">includeCurrent</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (i - k &gt;= <span class="hljs-number">0</span>) &#123;<br>                includeCurrent += dp[i - k];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (includeCurrent &gt; dp[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = includeCurrent;<br>                selected[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (i - k &gt;= <span class="hljs-number">0</span>) &#123;<br>                    selected[i - k] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>                selected[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印出选中的数</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (selected[i]) &#123;<br>                result.add(<span class="hljs-number">0</span>, nums[i]);<br>                i -= k;  <span class="hljs-comment">// 如果选择了 nums[i]，那么就跳过 i 和前 k-1 个数</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;  <span class="hljs-comment">// 如果没选择 nums[i]，就继续向前看</span><br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Selected numbers: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;Maximum non-adjacent sum with k=&quot;</span> + k + <span class="hljs-string">&quot;: &quot;</span> + maxNonAdjacentSum(nums, k));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>先更新还是先计数</title>
    <link href="/2024/08/15/%E5%85%88%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%85%88%E8%AE%A1%E6%95%B0/"/>
    <url>/2024/08/15/%E5%85%88%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%85%88%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣560：应该先计算前缀和还是先count"><a href="#力扣560：应该先计算前缀和还是先count" class="headerlink" title="力扣560：应该先计算前缀和还是先count"></a>力扣560：应该先计算前缀和还是先count</h1><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a>的标准做法是使用前缀和并通过哈希表优化，但是在主循环中，count和计算前缀和的顺序大部分解答都完全没有提及，看起来好像是不重要的，但是我在写这道题的时候却觉得没有那么“显然”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; preMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        preMap.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            pre = pre + nums[i];<br>            <span class="hljs-comment">// put or count first?</span><br>            <span class="hljs-keyword">if</span> (preMap.containsKey(pre - k)) &#123;<br>                count += preMap.get(pre - k);<br>            &#125;<br><br>            preMap(pre, preMap.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先说结论，必须是<strong>先put后count</strong>，不然在k&#x3D;0，且nums数组包含0的时候会出错。</p><h3 id="前缀和的思路"><a href="#前缀和的思路" class="headerlink" title="前缀和的思路"></a>前缀和的思路</h3><p>可以考虑$[i…j]$这个区间的和为k，</p><p>使用前缀和思想：$pre[j] - pre[i-1] &#x3D; k$</p><p>即$pre[j] &#x3D; k + pre[i-1]$</p><p>当我们遍历到$j$的时候，需要统计前面所有的$0,…,j-1$到$j$的和。</p><p>可以使用哈希表辅助查询，我们已经有了$pre[j]$</p><p>直接用该值去查询$key$对应的$value$即可。</p><h3 id="为什么要先put后count"><a href="#为什么要先put后count" class="headerlink" title="为什么要先put后count"></a>为什么要先put后count</h3><p>还是回到$pre[j] &#x3D; k+pre[i-1]$</p><p>其实我们就是需要找到$i-1$和$j$夹缝之间的一段序列，然后这段序列刚好为$k$，</p><p>那么如果先put，就意味着$i-1$可以等于$j$，继而夹缝为空，所以一段空数组等于$k$，显然不行。</p><p>所以就需要先put后count</p><h3 id="具体证明"><a href="#具体证明" class="headerlink" title="具体证明"></a>具体证明</h3><p>上面的说法看起来还不够有力，我们来具体证明一下吧。</p><p>只有当$k&#x3D;0$的时候有影响，因为只有当k&#x3D;0的时候，本次循环中put的pre[j]值才会立即被count表达式中的pre[j]-k用到，</p><p>所以只考虑$k&#x3D;0$的情况：</p><p>Map中存储的是各种前缀和的记录，如果是先put，我们考虑数组$[0,…,j-1]$都不为$0$，且$nums[j] &#x3D; 0$。</p><p>显然这时候从$pre[0]$到$pre[i]$都不为$0$，且$pre[i] &#x3D; pre[j]$。</p><p>那么在put的时候，因为$pre[i] &#x3D; pre[j]$，所以这一项的$value&#x3D;2$。</p><p>之后count的时候，显然count也为$2$，即和为$k$的子数组为$2$，显然错误，证明完毕。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
